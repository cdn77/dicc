# Simple services

Simple services, which don't require any special options and whose dependencies
can be resolved automatically by the compiler, need only to be discoverable by
the compiler as exports from one of the resource files:

```typescript
// this will register the ServiceOne class as a service and it will also
// automatically include any interfaces ServiceOne implements, as well as
// its ancestors and their interfaces, as aliases:
export { ServiceOne } from '../services';

// assuming ServiceTwoInterface is actually an interface, this will register
// a dynamic service of the ServiceTwoInterface type; any other interfaces which
// ServiceTwoInterface extends will be registered as its aliases:
export { ServiceTwoInterface } from '../services';
```

Services registered this way will not have a public service ID. They will have
autogenerated string identifiers beginning with a `#` character, but you're
strongly discouraged from using these, because they're a product of the
compilation process and can change at any time, even between compilations in
some cases. Instead, you should rely on injection to get instances of these
services. You know, the thing you're using this library for.

> There is a special case for classes which don't have any public constructors,
> but which have a static `create()` method: if such a class is found, it will
> be registered and the `create()` method will be used at runtime as the service
> factory.

When you need to do some more complex logic to create a service instance, or
when you want to provide other service configuration such as a scope or one or
more service hooks, you can export a _service definition_ from a resource file.

**Next**: [Explicit service definitions][1]

[1]: ./04-explicit-definitions.md
